# 섹션 03. 영속성 관리 - 내부 동작 방식
## 01. 영속성 컨텍스트 1
JPA 에서 가장 중요한 것 2가지를 뽑자면
1. 객체와 관계형 데이터베이스 매핑 (Object Relationship Mapping)
2. 영속성 컨텍스트
	- 해당 부분을 이해하면 `JPA`가 `내부적으로 어떻게 동작하는지`에 대해서 알 수 있음
### EntityManagerFactory 와 EntityManager
`엔티티 매니저 팩토리`는 고객 요청마다 `엔티티 매니저`를 생성한다.  
<br/><br/>

### 영속성 컨텍스트
`JPA`를 이해하는데 가장 중요한 용어로, `엔티티를 영구 저장하는 환경`이라는 뜻이며 `논리적인 개념`이다.
- `EntityManager.persist(entity);`
	- `entity`를 `DB에 저장`한다는게 아니라, `영속성 컨텍스트`를 통해 엔티티를 `영속화`하는 거라 봐야함
	- 즉 `persiste()`는 엔티티를 `영속성 컨텍스트`라는 데 저장 함
- `논리적 개념`이기에 눈에 보이지 않으며, `엔티티 매니저`를 통해 접근 가능하다.
- `Application`과 `DB` 사이에 어떠한 `중간계층`이 있다고 생각하면 이해하기 쉽다.  
<br/><br/>

### 엔티티의 생명주기
![img_001](./imageFiles/img_001)
- `비영속 (new/transient)`: 영속성 컨텍스트와 관계 없는 `새로운` 상태
	- 한 마디로 최초의 `객체`를 생성한 상태로 보면 됨
- `영속 (managed)`: 영속성 컨텍스트에 `관리`되는 상태
	- `EntityManager.persist()`하면 `영속 상태`가 됨
- `준영속 (detached)`: 영속성 컨텍스트에 저장되었다가 `분리`된 상태
- `삭제 (removed)`: `삭제`된 상태
#### 비영속
`JPA`와 전혀 관계 없이 딱 `객체`를 `생성하고 세팅만` 한 상태
```
// 비영속 상태 예시 코드
Member member = new Member();	// 새로운 멤버 객체 생성
member.setId(1L);				// 멤버 객체에 값 세팅
member.setName("hello");
```  
<br/>

#### 영속
`EntityManager.persist()`를 통해 `객체`를 `영속성 컨텍스트에 넣은 상태`
```
// 영속 상태 예시 코드
Member member = new Member();	// 새로운 멤버 객체 생성
member.setId(1L);				// 멤버 객체에 값 세팅
member.setName("hello");

EntityManager em = emf.createEntityManager();	// 새로운 엔티티 매니저 생성
em.getTransaction().begin();					// 트랜잭션 시작

em.persist(member);								// 객체 영속화
```
- 엔티티를 `영속화`한다고 해서 바로 `DB`에 저장하는 쿼리가 날라가지 않는다.
	- 그렇다 `트랜잭션이 커밋되는 시점`에 `영속성 컨텍스트에 있는 엔티티에 대한 쿼리`가 `DB`에 날아가게 됨  
<br/>

#### 준영속
`엔티티`를 영속성 컨텍스트에서 분리함, 아무런 관계가 없어짐
```
em.detach(member);
```  
<br/>

#### 삭제
실제 `DB 삭제`를 요청하는 상태
```
em.remove(member);
```  
<br/><br/><br/>

## 02. 영속성 컨텍스트 2
### 영속성 컨텍스트의 이점
- 1차 캐시
- `동일성(indentity)` 보장
- 트랜잭션을 지원하는 `쓰기 지연(transactional write-behind)`
- `변경 감지(Dirty Checking)`
- `지연 로딩(Lazy Loading)`  
<br/><br/>

### 엔티티 조회, 1차 캐시
영속성 컨텍스트는 내부에 `1차 캐시`라는 것을 가지고 있다.
- `EntityManager.persist(entity)` 메서드가 수행되면 영속성 컨텍스트에 `1차 캐시`가 생성된다.
	- `1차 캐시`는 `Map`으로 `key` 값으로 `엔티티의 PK`, `value` 값으로 `엔티티`를 가진다.
#### 1차 캐시를 생성하면 어떤 점이 좋을까?
예를 들어 어떠한 엔티티를 조회한다고 가정하자.
```
// 'member_id(@Id)' 값을 통해서 Member 객체를 조회
Member findMember = EntityManager.find(Member.Class, {member_id});
```
- 엔티티 매니저는 `@Id` 값을 가지고 `DB가 아니라` `영속성 컨텍스트의 1차 캐시`에서 `멤버 엔티티`를 찾는다.
	- `1차 캐시`에 해당하는 `멤버 엔티티` 데이터가 있다면 그 데이터를 그대로 조회해 온다. 
	- 만약 `1차 캐시`에 해당하는 `멤버 엔티티`가 없다면?
		- `DB`에서 `멤버 엔티티`를  조회하고, 조회한 `멤버 엔티티`를 `1차 캐시`에 저장한다.
		- 그런 다음 해당 `멤버 엔티티`를 반환한다.
- 하지만 이 이점은 너무 `찰나의 순간`이라고 말 할 수 있다.
	- 왜냐하면 `엔티티 매니저`는 `트랜잭션 종료(요청 수행 끝)`시 종료된다.
	- 당연히 `영속성 컨텍스트`도 `1차 캐시`도 이 때, `전부 종료된다(지워진다)`.  
<br/><br/>

### 동일성 보장
영속화된 `엔티티`의 동일성을 보장한다.
```
// 아래처럼 영속화된 같은 엔티티를 조회해 비교하면 같다는 결과를 얻을 수 있다.
Member a = EntityManager.find(Member.class, "memberA");
Member b = EntityManager.find(Member.class, "memberA");

System.out.println(a == b);	// true 반환
```
- 물론 위의 내용은 `같은 트랜잭션 내`에서만 해당하는 내용이다.  
<br/><br/>

### 엔티티 등록 - 트랜잭션을 지원하는 쓰기 지연
위에서 `엔티티 영속 상태`에 대한 설명에서 잠깐 나왔던 내용이다. 
```
// 예시 코드
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
tx.begin();		// 트랜잭션 시작
				// 엔티티 매니저는 데이터 변경 시 트랜잭션을 시작해야 함

// 엔티티 영속화
em.persist(memberA);
em.persist(memberB);	// 해당 시점까지도 INSERT QUERY 를 DB 에 보내지 않음

// 트랜잭션 커밋
tx.commit();			// 이 시점에 DB 에 INSERT QUERY 를 날림
```
`엔티티 영속화 != DB 저장`인 것은 위에서 설명되었다.
- 영속성 컨텍스트에는 `1차 캐시` 외에도 `쓰기 지연 SQL 저장소`라는 것이 존재한다.
	- 어떠한 엔티티가 영속화를 거치면 `1차 캐시`에 엔티티를 저장하고 `요청에 따른 SQL`이 `쓰기 지연 SQL 저장소에 저장`된다.
	- 즉, 요청에 따른 `SQL` 쿼리가 요청마다 `DB`에 바로 날라가는 것이 아니라 `쌓이게 된다`.
	- 최종적으로 트랜잭션을 `commit`하게 되면 쌓인 `SQL`에 대한 쿼리 `한 번에` `DB`에 날라가게 된다.
		- 트랜잭션이 커밋 되면 `JPA`에서는 `flush(플러쉬)`를 통해 `영속성 컨텍스트의 정보를 DB 에 반영`한다.  
<br/><br/>

### 엔티티 수정 - 변경 감지
`Dirty Checking`이라 말하며, 엔티티의 변경을 감지하여 변경 사항을 업데이트 해준다.
```
// 예시 코드
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
tx.begin();		// 트랜잭션 시작

// 영속 엔티티 조회
Member findMember = em.find(Member.class, {member_id});
// 조회한 영속 엔티티 데이터 수정
findMember.setName("changeName");

// em.persist(findMember); << 해당 코드가 있어야 할까?

tx.commit();	// 트랜잭션 커밋
```
수정을 한 뒤에는 수정된 엔티티를 `다시 영속화`해 `DB`에 저장하도록 `JPA`에 요청을 해야 할 것 같다.
- 하지만 `별도의 요청 없이` 업데이트 내용이 `DB`에 반영되는 것을 확인 할 수 있다.
#### 어떻게 가능한 걸까?
`영속성 컨텍스트의 1차 캐시`에는 `스냅샷`이라는 것이 있는데, 이는 영속 엔티티의 최초 시점 상태를 저장한 것이다.
- `트랜잭션 커밋`이 수행되면 `JPA` 내부적으로 `flush()`가 호출 되면서 `1차 캐시`의 `엔티티와 스냅샷을 비교`한다.
	- 만약 변경이 확인되면 그에 해당하는 `UPDATE SQL`을 생성 후, `DB`에 `SQL 쿼리`를 날리고 `commit` 된다.  
<br/><br/>

### 엔티티 삭제
엔티티를 `DB`에서 삭제한다.
```
// 영속 엔티티 조회
Member findMember = em.find(Member.class, {member_id});

em.remove(findMember);	// 엔티티 삭제
```
메커니즘은 `엔티티 수정`과 같다.
- 트랜잭션 커밋 시점에 생성된 `DELETE QUERY`가 `DB`에 날라가고 `commit` 된다.  
<br/><br/><br/>

## 03. 플러시
영속성 컨텍스트의 `변경내용`을 `DB`에 반영한다.
- `영속성 컨텍스트의 정보`와 `DB의 정보`를 일치시키는 작업이라고 보면 된다.
- 보통 `트랜잭션 커밋`이 될 때 `플러시`가 일어난다.
	1. 영속성 컨텍스트의 `1차 캐시`로 `변경을 감지`한다.
	2. 감지된 변경에 대한 `SQL`을 `쓰기 지연 SQL 저장소`에 저장한다.
	3. 영속성 컨텍스트의 `쓰기 지연 SQL 저장소`에 쌓인 `SQL QUERY`가 `DB`로 전달, 변경사항을 반영한다.
### 사용 방법
1. `em.flush()`: 직접 호출
2. `트랜잭션 commit()`: 플러시 자동 호출
3. `JPQL 쿼리 실행`: 플러시 자동 호출
	- `JPA`는 기본적으로 `JPQL 쿼리` 실행 시 `flush()`를 날려버림
	- 아직 `DB`에 반영되지 않은 데이터로 인한 문제를 방지하기 위해  
<br/><br/>

### 정리
`플러시`는 영속성 컨텍스트의 `변경사항`을 DB 에 `동기화 한다.
- `트랜잭션 커밋`처럼 영속성 컨텍스트를 `비우지 않음`
- `트랜잭션`이라는 작업단위가 중요하다.
	- `작업단위(트랜잭션)`가 존재하기에 `변경 SQL 을 쌓아두었다가` 커밋 직전에만 `DB 와 동기화`하는 메커니즘을 사용 할 수 있다.  
<br/><br/><br/>

## 04. 준영속 상태
`영속 엔티티`가 영속성 컨텍스트에서 `분리된 상태`
- `JPA`가 관리하지 않는 상태가 된다.
	- 트랜잭션 커밋이 수행되도 `영속성 컨텍스트에서 분리` 되었기 때문에 `DB`에 반영되지 않는다.
	- `JPA`가 트랜잭션 커밋 시점에 `flush()`를 호출한다고 해도 해당 엔티티는 영속성 컨텍스트에 없기 때문
### 준영속 상태로 만드는 방법
- `em.detach(entity)`: `특정 엔티티만`을 준영속 상태로 전환
- `em.clear()`: `영속성 컨텍스트`를 완전히 `초기화(1차 캐시 초기화)`
- `em.close()`: `영속성 컨텍스트 종료`